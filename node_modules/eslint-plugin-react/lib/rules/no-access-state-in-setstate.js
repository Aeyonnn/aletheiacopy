/**
 * @fileoverview Prevent usage of this.state within setState
 * @author Rolf Erik Lekang, JÃ¸rgen Aaberg
 */

'use strict';

const docsUrl = require('../util/docsUrl');
<<<<<<< HEAD
=======
const Components = require('../util/Components');
const report = require('../util/report');
>>>>>>> d9d57759386cbc64761f26a577729c9da898f4b0

// ------------------------------------------------------------------------------
// Rule Definition
// ------------------------------------------------------------------------------

<<<<<<< HEAD
=======
const messages = {
  useCallback: 'Use callback in setState when referencing the previous state.',
};

>>>>>>> d9d57759386cbc64761f26a577729c9da898f4b0
module.exports = {
  meta: {
    docs: {
      description: 'Reports when this.state is accessed within setState',
      category: 'Possible Errors',
      recommended: false,
<<<<<<< HEAD
      url: docsUrl('no-access-state-in-setstate')
    }
  },

  create: function(context) {
    function isSetStateCall(node) {
      return node.type === 'CallExpression' &&
        node.callee.property &&
        node.callee.property.name === 'setState' &&
        node.callee.object.type === 'ThisExpression';
=======
      url: docsUrl('no-access-state-in-setstate'),
    },

    messages,
  },

  create: Components.detect((context, components, utils) => {
    function isSetStateCall(node) {
      return node.type === 'CallExpression'
        && node.callee.property
        && node.callee.property.name === 'setState'
        && node.callee.object.type === 'ThisExpression';
>>>>>>> d9d57759386cbc64761f26a577729c9da898f4b0
    }

    function isFirstArgumentInSetStateCall(current, node) {
      if (!isSetStateCall(current)) {
        return false;
      }
      while (node && node.parent !== current) {
        node = node.parent;
      }
      return current.arguments[0] === node;
    }

<<<<<<< HEAD
=======
    function isClassComponent() {
      return !!(utils.getParentES6Component() || utils.getParentES5Component());
    }

>>>>>>> d9d57759386cbc64761f26a577729c9da898f4b0
    // The methods array contains all methods or functions that are using this.state
    // or that are calling another method or function using this.state
    const methods = [];
    // The vars array contains all variables that contains this.state
    const vars = [];
    return {
      CallExpression(node) {
<<<<<<< HEAD
        // Appends all the methods that are calling another
        // method containing this.state to the methods array
        methods.map(method => {
=======
        if (!isClassComponent()) {
          return;
        }
        // Appends all the methods that are calling another
        // method containing this.state to the methods array
        methods.forEach((method) => {
>>>>>>> d9d57759386cbc64761f26a577729c9da898f4b0
          if (node.callee.name === method.methodName) {
            let current = node.parent;
            while (current.type !== 'Program') {
              if (current.type === 'MethodDefinition') {
                methods.push({
                  methodName: current.key.name,
<<<<<<< HEAD
                  node: method.node
=======
                  node: method.node,
>>>>>>> d9d57759386cbc64761f26a577729c9da898f4b0
                });
                break;
              }
              current = current.parent;
            }
          }
        });

        // Finding all CallExpressions that is inside a setState
        // to further check if they contains this.state
        let current = node.parent;
        while (current.type !== 'Program') {
          if (isFirstArgumentInSetStateCall(current, node)) {
            const methodName = node.callee.name;
<<<<<<< HEAD
            methods.map(method => {
              if (method.methodName === methodName) {
                context.report(
                  method.node,
                  'Use callback in setState when referencing the previous state.'
                );
=======
            methods.forEach((method) => {
              if (method.methodName === methodName) {
                report(context, messages.useCallback, 'useCallback', {
                  node: method.node,
                });
>>>>>>> d9d57759386cbc64761f26a577729c9da898f4b0
              }
            });

            break;
          }
          current = current.parent;
        }
      },

      MemberExpression(node) {
        if (
<<<<<<< HEAD
          node.property.name === 'state' &&
          node.object.type === 'ThisExpression'
=======
          node.property.name === 'state'
          && node.object.type === 'ThisExpression'
          && isClassComponent()
>>>>>>> d9d57759386cbc64761f26a577729c9da898f4b0
        ) {
          let current = node;
          while (current.type !== 'Program') {
            // Reporting if this.state is directly within this.setState
            if (isFirstArgumentInSetStateCall(current, node)) {
<<<<<<< HEAD
              context.report(
                node,
                'Use callback in setState when referencing the previous state.'
              );
=======
              report(context, messages.useCallback, 'useCallback', {
                node,
              });
>>>>>>> d9d57759386cbc64761f26a577729c9da898f4b0
              break;
            }

            // Storing all functions and methods that contains this.state
            if (current.type === 'MethodDefinition') {
              methods.push({
                methodName: current.key.name,
<<<<<<< HEAD
                node: node
=======
                node,
>>>>>>> d9d57759386cbc64761f26a577729c9da898f4b0
              });
              break;
            } else if (current.type === 'FunctionExpression' && current.parent.key) {
              methods.push({
                methodName: current.parent.key.name,
<<<<<<< HEAD
                node: node
=======
                node,
>>>>>>> d9d57759386cbc64761f26a577729c9da898f4b0
              });
              break;
            }

            // Storing all variables containg this.state
            if (current.type === 'VariableDeclarator') {
              vars.push({
<<<<<<< HEAD
                node: node,
                scope: context.getScope(),
                variableName: current.id.name
=======
                node,
                scope: context.getScope(),
                variableName: current.id.name,
>>>>>>> d9d57759386cbc64761f26a577729c9da898f4b0
              });
              break;
            }

            current = current.parent;
          }
        }
      },

      Identifier(node) {
        // Checks if the identifier is a variable within an object
        let current = node;
        while (current.parent.type === 'BinaryExpression') {
          current = current.parent;
        }
        if (
<<<<<<< HEAD
          current.parent.value === current ||
          current.parent.object === current
=======
          current.parent.value === current
          || current.parent.object === current
>>>>>>> d9d57759386cbc64761f26a577729c9da898f4b0
        ) {
          while (current.type !== 'Program') {
            if (isFirstArgumentInSetStateCall(current, node)) {
              vars
<<<<<<< HEAD
                .filter(v => v.scope === context.getScope() && v.variableName === node.name)
                .map(v => context.report(
                  v.node,
                  'Use callback in setState when referencing the previous state.'
                ));
=======
                .filter((v) => v.scope === context.getScope() && v.variableName === node.name)
                .forEach((v) => {
                  report(context, messages.useCallback, 'useCallback', {
                    node: v.node,
                  });
                });
>>>>>>> d9d57759386cbc64761f26a577729c9da898f4b0
            }
            current = current.parent;
          }
        }
      },

      ObjectPattern(node) {
        const isDerivedFromThis = node.parent.init && node.parent.init.type === 'ThisExpression';
<<<<<<< HEAD
        node.properties.forEach(property => {
=======
        node.properties.forEach((property) => {
>>>>>>> d9d57759386cbc64761f26a577729c9da898f4b0
          if (property && property.key && property.key.name === 'state' && isDerivedFromThis) {
            vars.push({
              node: property.key,
              scope: context.getScope(),
<<<<<<< HEAD
              variableName: property.key.name
            });
          }
        });
      }
    };
  }
=======
              variableName: property.key.name,
            });
          }
        });
      },
    };
  }),
>>>>>>> d9d57759386cbc64761f26a577729c9da898f4b0
};
