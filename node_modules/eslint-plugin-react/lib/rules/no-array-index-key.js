/**
 * @fileoverview Prevent usage of Array index in keys
 * @author Joe Lencioni
 */
<<<<<<< HEAD
'use strict';

const has = require('has');
const astUtil = require('../util/ast');
const docsUrl = require('../util/docsUrl');
=======

'use strict';

const has = require('object.hasown/polyfill')();
const astUtil = require('../util/ast');
const docsUrl = require('../util/docsUrl');
const pragma = require('../util/pragma');
const report = require('../util/report');
>>>>>>> d9d57759386cbc64761f26a577729c9da898f4b0

// ------------------------------------------------------------------------------
// Rule Definition
// ------------------------------------------------------------------------------

<<<<<<< HEAD
=======
const messages = {
  noArrayIndex: 'Do not use Array index in keys',
};

>>>>>>> d9d57759386cbc64761f26a577729c9da898f4b0
module.exports = {
  meta: {
    docs: {
      description: 'Prevent usage of Array index in keys',
      category: 'Best Practices',
      recommended: false,
<<<<<<< HEAD
      url: docsUrl('no-array-index-key')
    },

    schema: []
  },

  create: function(context) {
=======
      url: docsUrl('no-array-index-key'),
    },

    messages,

    schema: [],
  },

  create(context) {
>>>>>>> d9d57759386cbc64761f26a577729c9da898f4b0
    // --------------------------------------------------------------------------
    // Public
    // --------------------------------------------------------------------------
    const indexParamNames = [];
    const iteratorFunctionsToIndexParamPosition = {
      every: 1,
      filter: 1,
      find: 1,
      findIndex: 1,
      forEach: 1,
      map: 1,
      reduce: 2,
      reduceRight: 2,
<<<<<<< HEAD
      some: 1
    };
    const ERROR_MESSAGE = 'Do not use Array index in keys';
=======
      some: 1,
    };
>>>>>>> d9d57759386cbc64761f26a577729c9da898f4b0

    function isArrayIndex(node) {
      return node.type === 'Identifier'
        && indexParamNames.indexOf(node.name) !== -1;
    }

<<<<<<< HEAD
    function getMapIndexParamName(node) {
      const callee = node.callee;
      if (callee.type !== 'MemberExpression') {
=======
    function isUsingReactChildren(node) {
      const callee = node.callee;
      if (
        !callee
        || !callee.property
        || !callee.object
      ) {
        return null;
      }

      const isReactChildMethod = ['map', 'forEach'].indexOf(callee.property.name) > -1;
      if (!isReactChildMethod) {
        return null;
      }

      const obj = callee.object;
      if (obj && obj.name === 'Children') {
        return true;
      }
      if (obj && obj.object && obj.object.name === pragma.getFromContext(context)) {
        return true;
      }

      return false;
    }

    function getMapIndexParamName(node) {
      const callee = node.callee;
      if (callee.type !== 'MemberExpression' && callee.type !== 'OptionalMemberExpression') {
>>>>>>> d9d57759386cbc64761f26a577729c9da898f4b0
        return null;
      }
      if (callee.property.type !== 'Identifier') {
        return null;
      }
      if (!has(iteratorFunctionsToIndexParamPosition, callee.property.name)) {
        return null;
      }

<<<<<<< HEAD
      const firstArg = node.arguments[0];
      if (!firstArg) {
        return null;
      }

      if (!astUtil.isFunctionLikeExpression(firstArg)) {
        return null;
      }

      const params = firstArg.params;
=======
      const callbackArg = isUsingReactChildren(node)
        ? node.arguments[1]
        : node.arguments[0];

      if (!callbackArg) {
        return null;
      }

      if (!astUtil.isFunctionLikeExpression(callbackArg)) {
        return null;
      }

      const params = callbackArg.params;
>>>>>>> d9d57759386cbc64761f26a577729c9da898f4b0

      const indexParamPosition = iteratorFunctionsToIndexParamPosition[callee.property.name];
      if (params.length < indexParamPosition + 1) {
        return null;
      }

      return params[indexParamPosition].name;
    }

    function getIdentifiersFromBinaryExpression(side) {
      if (side.type === 'Identifier') {
        return side;
      }

      if (side.type === 'BinaryExpression') {
        // recurse
        const left = getIdentifiersFromBinaryExpression(side.left);
        const right = getIdentifiersFromBinaryExpression(side.right);
        return [].concat(left, right).filter(Boolean);
      }

      return null;
    }

    function checkPropValue(node) {
      if (isArrayIndex(node)) {
        // key={bar}
<<<<<<< HEAD
        context.report({
          node: node,
          message: ERROR_MESSAGE
=======
        report(context, messages.noArrayIndex, 'noArrayIndex', {
          node,
>>>>>>> d9d57759386cbc64761f26a577729c9da898f4b0
        });
        return;
      }

      if (node.type === 'TemplateLiteral') {
        // key={`foo-${bar}`}
        node.expressions.filter(isArrayIndex).forEach(() => {
<<<<<<< HEAD
          context.report({node: node, message: ERROR_MESSAGE});
=======
          report(context, messages.noArrayIndex, 'noArrayIndex', {
            node,
          });
>>>>>>> d9d57759386cbc64761f26a577729c9da898f4b0
        });

        return;
      }

      if (node.type === 'BinaryExpression') {
        // key={'foo' + bar}
        const identifiers = getIdentifiersFromBinaryExpression(node);

        identifiers.filter(isArrayIndex).forEach(() => {
<<<<<<< HEAD
          context.report({node: node, message: ERROR_MESSAGE});
        });

        return;
      }
    }

    return {
      CallExpression: function(node) {
        if (
          node.callee
          && node.callee.type === 'MemberExpression'
=======
          report(context, messages.noArrayIndex, 'noArrayIndex', {
            node,
          });
        });
      }
    }

    function popIndex(node) {
      const mapIndexParamName = getMapIndexParamName(node);
      if (!mapIndexParamName) {
        return;
      }

      indexParamNames.pop();
    }

    return {
      'CallExpression, OptionalCallExpression'(node) {
        if (
          node.callee
          && (node.callee.type === 'MemberExpression' || node.callee.type === 'OptionalMemberExpression')
>>>>>>> d9d57759386cbc64761f26a577729c9da898f4b0
          && ['createElement', 'cloneElement'].indexOf(node.callee.property.name) !== -1
          && node.arguments.length > 1
        ) {
          // React.createElement
          if (!indexParamNames.length) {
            return;
          }

          const props = node.arguments[1];

          if (props.type !== 'ObjectExpression') {
            return;
          }

<<<<<<< HEAD
          props.properties.forEach(prop => {
=======
          props.properties.forEach((prop) => {
>>>>>>> d9d57759386cbc64761f26a577729c9da898f4b0
            if (!prop.key || prop.key.name !== 'key') {
              // { ...foo }
              // { foo: bar }
              return;
            }

            checkPropValue(prop.value);
          });

          return;
        }

        const mapIndexParamName = getMapIndexParamName(node);
        if (!mapIndexParamName) {
          return;
        }

        indexParamNames.push(mapIndexParamName);
      },

<<<<<<< HEAD
      JSXAttribute: function(node) {
=======
      JSXAttribute(node) {
>>>>>>> d9d57759386cbc64761f26a577729c9da898f4b0
        if (node.name.name !== 'key') {
          // foo={bar}
          return;
        }

        if (!indexParamNames.length) {
          // Not inside a call expression that we think has an index param.
          return;
        }

        const value = node.value;
        if (!value || value.type !== 'JSXExpressionContainer') {
          // key='foo' or just simply 'key'
          return;
        }

        checkPropValue(value.expression);
      },

<<<<<<< HEAD
      'CallExpression:exit': function(node) {
        const mapIndexParamName = getMapIndexParamName(node);
        if (!mapIndexParamName) {
          return;
        }

        indexParamNames.pop();
      }
    };
  }
=======
      'CallExpression:exit': popIndex,
      'OptionalCallExpression:exit': popIndex,
    };
  },
>>>>>>> d9d57759386cbc64761f26a577729c9da898f4b0
};
