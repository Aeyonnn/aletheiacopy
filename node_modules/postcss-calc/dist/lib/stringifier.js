"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
<<<<<<< HEAD
var order = {
=======
const order = {
>>>>>>> d9d57759386cbc64761f26a577729c9da898f4b0
  "*": 0,
  "/": 0,
  "+": 1,
  "-": 1
};
<<<<<<< HEAD

function round(value, prec) {
  if (prec !== false) {
    var precision = Math.pow(10, prec);
=======
/**
 * @param {number} value
 * @param {number | false} prec
 */

function round(value, prec) {
  if (prec !== false) {
    const precision = Math.pow(10, prec);
>>>>>>> d9d57759386cbc64761f26a577729c9da898f4b0
    return Math.round(value * precision) / precision;
  }

  return value;
}
<<<<<<< HEAD
=======
/**
 * @param {number | false} prec
 * @param {import('../parser').CalcNode} node
 *
 * @return {string}
 */

>>>>>>> d9d57759386cbc64761f26a577729c9da898f4b0

function stringify(node, prec) {
  switch (node.type) {
    case "MathExpression":
      {
<<<<<<< HEAD
        var left = node.left,
            right = node.right,
            op = node.operator;
        var str = "";
=======
        const {
          left,
          right,
          operator: op
        } = node;
        let str = "";
>>>>>>> d9d57759386cbc64761f26a577729c9da898f4b0

        if (left.type === 'MathExpression' && order[op] < order[left.operator]) {
          str += `(${stringify(left, prec)})`;
        } else {
          str += stringify(left, prec);
        }

        str += order[op] ? ` ${node.operator} ` : node.operator;

        if (right.type === 'MathExpression' && order[op] < order[right.operator]) {
          str += `(${stringify(right, prec)})`;
        } else {
          str += stringify(right, prec);
        }

        return str;
      }

    case 'Number':
<<<<<<< HEAD
      return round(node.value, prec);

    case 'Function':
      return node.value;
=======
      return round(node.value, prec).toString();

    case 'Function':
      return node.value.toString();

    case 'ParenthesizedExpression':
      return `(${stringify(node.content, prec)})`;
>>>>>>> d9d57759386cbc64761f26a577729c9da898f4b0

    default:
      return round(node.value, prec) + node.unit;
  }
}
<<<<<<< HEAD

function _default(calc, node, originalValue, options, result, item) {
  var str = stringify(node, options.precision);
  var shouldPrintCalc = node.type === "MathExpression" || node.type === "Function";
=======
/**
 * @param {string} calc
 * @param {import('../parser').CalcNode} node
 * @param {string} originalValue
 * @param {{precision: number | false, warnWhenCannotResolve: boolean}} options
 * @param {import("postcss").Result} result
 * @param {import("postcss").ChildNode} item
 *
 * @returns {string}
 */


function _default(calc, node, originalValue, options, result, item) {
  let str = stringify(node, options.precision);
  const shouldPrintCalc = node.type === "MathExpression" || node.type === "Function";
>>>>>>> d9d57759386cbc64761f26a577729c9da898f4b0

  if (shouldPrintCalc) {
    // if calc expression couldn't be resolved to a single value, re-wrap it as
    // a calc()
    str = `${calc}(${str})`; // if the warnWhenCannotResolve option is on, inform the user that the calc
    // expression could not be resolved to a single value

    if (options.warnWhenCannotResolve) {
      result.warn("Could not reduce expression: " + originalValue, {
        plugin: 'postcss-calc',
        node: item
      });
    }
  }

  return str;
}

module.exports = exports.default;