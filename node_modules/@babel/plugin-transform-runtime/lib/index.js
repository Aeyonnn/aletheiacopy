"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

<<<<<<< HEAD
function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function () {
    return data;
  };

  return data;
}

function _resolve() {
  const data = _interopRequireDefault(require("resolve"));

  _resolve = function () {
    return data;
  };

  return data;
}

function _helperPluginUtils() {
  const data = require("@babel/helper-plugin-utils");

  _helperPluginUtils = function () {
    return data;
  };

  return data;
}

function _helperModuleImports() {
  const data = require("@babel/helper-module-imports");

  _helperModuleImports = function () {
    return data;
  };

  return data;
}

function _core() {
  const data = require("@babel/core");

  _core = function () {
    return data;
  };

  return data;
}

var _definitions = _interopRequireDefault(require("./definitions"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function resolveAbsoluteRuntime(moduleName, dirname) {
  try {
    return _path().default.dirname(_resolve().default.sync(`${moduleName}/package.json`, {
      basedir: dirname
    }));
  } catch (err) {
    if (err.code !== "MODULE_NOT_FOUND") throw err;
    throw Object.assign(new Error(`Failed to resolve "${moduleName}" relative to "${dirname}"`), {
      code: "BABEL_RUNTIME_NOT_FOUND",
      runtime: moduleName,
      dirname
    });
  }
}

function supportsStaticESM(caller) {
  return !!(caller && caller.supportsStaticESM);
}

var _default = (0, _helperPluginUtils().declare)((api, options, dirname) => {
  api.assertVersion(7);
  const {
    corejs: corejsVersion = false,
=======
var _helperPluginUtils = require("@babel/helper-plugin-utils");

var _helperModuleImports = require("@babel/helper-module-imports");

var _core = require("@babel/core");

var _helpers = require("./helpers");

var _getRuntimePath = require("./get-runtime-path");

var _babelPluginPolyfillCorejs = require("babel-plugin-polyfill-corejs2");

var _babelPluginPolyfillCorejs2 = require("babel-plugin-polyfill-corejs3");

var _babelPluginPolyfillRegenerator = require("babel-plugin-polyfill-regenerator");

const pluginCorejs2 = _babelPluginPolyfillCorejs.default || _babelPluginPolyfillCorejs;
const pluginCorejs3 = _babelPluginPolyfillCorejs2.default || _babelPluginPolyfillCorejs2;
const pluginRegenerator = _babelPluginPolyfillRegenerator.default || _babelPluginPolyfillRegenerator;
const pluginsCompat = "#__secret_key__@babel/runtime__compatibility";

function supportsStaticESM(caller) {
  return !!(caller != null && caller.supportsStaticESM);
}

var _default = (0, _helperPluginUtils.declare)((api, options, dirname) => {
  api.assertVersion(7);
  const {
    corejs,
>>>>>>> d9d57759386cbc64761f26a577729c9da898f4b0
    helpers: useRuntimeHelpers = true,
    regenerator: useRuntimeRegenerator = true,
    useESModules = false,
    version: runtimeVersion = "7.0.0-beta.0",
    absoluteRuntime = false
  } = options;
<<<<<<< HEAD
  const definitions = (0, _definitions.default)(runtimeVersion);
=======
  let proposals = false;
  let rawVersion;

  if (typeof corejs === "object" && corejs !== null) {
    rawVersion = corejs.version;
    proposals = Boolean(corejs.proposals);
  } else {
    rawVersion = corejs;
  }

  const corejsVersion = rawVersion ? Number(rawVersion) : false;

  if (![false, 2, 3].includes(corejsVersion)) {
    throw new Error(`The \`core-js\` version must be false, 2 or 3, but got ${JSON.stringify(rawVersion)}.`);
  }

  if (proposals && (!corejsVersion || corejsVersion < 3)) {
    throw new Error("The 'proposals' option is only supported when using 'corejs: 3'");
  }
>>>>>>> d9d57759386cbc64761f26a577729c9da898f4b0

  if (typeof useRuntimeRegenerator !== "boolean") {
    throw new Error("The 'regenerator' option must be undefined, or a boolean.");
  }

  if (typeof useRuntimeHelpers !== "boolean") {
    throw new Error("The 'helpers' option must be undefined, or a boolean.");
  }

  if (typeof useESModules !== "boolean" && useESModules !== "auto") {
    throw new Error("The 'useESModules' option must be undefined, or a boolean, or 'auto'.");
  }

  if (typeof absoluteRuntime !== "boolean" && typeof absoluteRuntime !== "string") {
    throw new Error("The 'absoluteRuntime' option must be undefined, a boolean, or a string.");
  }

<<<<<<< HEAD
  if (corejsVersion !== false && (typeof corejsVersion !== "number" || corejsVersion !== 2) && (typeof corejsVersion !== "string" || corejsVersion !== "2")) {
    throw new Error(`The 'corejs' option must be undefined, false, 2 or '2', ` + `but got ${JSON.stringify(corejsVersion)}.`);
  }

=======
>>>>>>> d9d57759386cbc64761f26a577729c9da898f4b0
  if (typeof runtimeVersion !== "string") {
    throw new Error(`The 'version' option must be a version string.`);
  }

<<<<<<< HEAD
=======
  {
    const DUAL_MODE_RUNTIME = "7.13.0";
    var supportsCJSDefault = (0, _helpers.hasMinVersion)(DUAL_MODE_RUNTIME, runtimeVersion);
  }

>>>>>>> d9d57759386cbc64761f26a577729c9da898f4b0
  function has(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
  }

  if (has(options, "useBuiltIns")) {
    if (options.useBuiltIns) {
      throw new Error("The 'useBuiltIns' option has been removed. The @babel/runtime " + "module now uses builtins by default.");
    } else {
<<<<<<< HEAD
      throw new Error("The 'useBuiltIns' option has been removed. Use the 'corejs'" + "option with value '2' to polyfill with CoreJS 2.x via @babel/runtime.");
=======
      throw new Error("The 'useBuiltIns' option has been removed. Use the 'corejs'" + "option to polyfill with `core-js` via @babel/runtime.");
>>>>>>> d9d57759386cbc64761f26a577729c9da898f4b0
    }
  }

  if (has(options, "polyfill")) {
    if (options.polyfill === false) {
      throw new Error("The 'polyfill' option has been removed. The @babel/runtime " + "module now skips polyfilling by default.");
    } else {
<<<<<<< HEAD
      throw new Error("The 'polyfill' option has been removed. Use the 'corejs'" + "option with value '2' to polyfill with CoreJS 2.x via @babel/runtime.");
=======
      throw new Error("The 'polyfill' option has been removed. Use the 'corejs'" + "option to polyfill with `core-js` via @babel/runtime.");
>>>>>>> d9d57759386cbc64761f26a577729c9da898f4b0
    }
  }

  if (has(options, "moduleName")) {
    throw new Error("The 'moduleName' option has been removed. @babel/transform-runtime " + "no longer supports arbitrary runtimes. If you were using this to " + "set an absolute path for Babel's standard runtimes, please use the " + "'absoluteRuntime' option.");
  }

  const esModules = useESModules === "auto" ? api.caller(supportsStaticESM) : useESModules;
<<<<<<< HEAD
  const injectCoreJS2 = `${corejsVersion}` === "2";
  const moduleName = injectCoreJS2 ? "@babel/runtime-corejs2" : "@babel/runtime";
  const HEADER_HELPERS = ["interopRequireWildcard", "interopRequireDefault"];
  let modulePath = moduleName;

  if (absoluteRuntime !== false) {
    modulePath = resolveAbsoluteRuntime(moduleName, _path().default.resolve(dirname, absoluteRuntime === true ? "." : absoluteRuntime));
=======
  const injectCoreJS2 = corejsVersion === 2;
  const injectCoreJS3 = corejsVersion === 3;
  const moduleName = injectCoreJS3 ? "@babel/runtime-corejs3" : injectCoreJS2 ? "@babel/runtime-corejs2" : "@babel/runtime";
  const HEADER_HELPERS = ["interopRequireWildcard", "interopRequireDefault"];
  const modulePath = (0, _getRuntimePath.default)(moduleName, dirname, absoluteRuntime);

  function createCorejsPlgin(plugin, options, regeneratorPlugin) {
    return (api, _, filename) => {
      return Object.assign({}, plugin(api, options, filename), {
        inherits: regeneratorPlugin
      });
    };
  }

  function createRegeneratorPlugin(options) {
    if (!useRuntimeRegenerator) return undefined;
    return (api, _, filename) => {
      return pluginRegenerator(api, options, filename);
    };
>>>>>>> d9d57759386cbc64761f26a577729c9da898f4b0
  }

  return {
    name: "transform-runtime",
<<<<<<< HEAD

    pre(file) {
      if (useRuntimeHelpers) {
        file.set("helperGenerator", name => {
          if (file.availableHelper && !file.availableHelper(name, runtimeVersion)) {
            return;
          }

          const isInteropHelper = HEADER_HELPERS.indexOf(name) !== -1;
          const blockHoist = isInteropHelper && !(0, _helperModuleImports().isModule)(file.path) ? 4 : undefined;
          const helpersDir = esModules && file.path.node.sourceType === "module" ? "helpers/esm" : "helpers";
          return this.addDefaultImport(`${modulePath}/${helpersDir}/${name}`, name, blockHoist);
        });
      }

      const cache = new Map();

      this.addDefaultImport = (source, nameHint, blockHoist) => {
        const cacheKey = (0, _helperModuleImports().isModule)(file.path);
=======
    inherits: injectCoreJS2 ? createCorejsPlgin(pluginCorejs2, {
      method: "usage-pure",
      absoluteImports: absoluteRuntime ? modulePath : false,
      [pluginsCompat]: {
        runtimeVersion,
        useBabelRuntime: modulePath,
        ext: ""
      }
    }, createRegeneratorPlugin({
      method: "usage-pure",
      absoluteImports: absoluteRuntime ? modulePath : false,
      [pluginsCompat]: {
        useBabelRuntime: modulePath
      }
    })) : injectCoreJS3 ? createCorejsPlgin(pluginCorejs3, {
      method: "usage-pure",
      version: 3,
      proposals,
      absoluteImports: absoluteRuntime ? modulePath : false,
      [pluginsCompat]: {
        useBabelRuntime: modulePath,
        ext: ""
      }
    }, createRegeneratorPlugin({
      method: "usage-pure",
      absoluteImports: absoluteRuntime ? modulePath : false,
      [pluginsCompat]: {
        useBabelRuntime: modulePath
      }
    })) : createRegeneratorPlugin({
      method: "usage-pure",
      absoluteImports: absoluteRuntime ? modulePath : false,
      [pluginsCompat]: {
        useBabelRuntime: modulePath
      }
    }),

    pre(file) {
      if (!useRuntimeHelpers) return;
      file.set("helperGenerator", name => {
        if (file.availableHelper && !file.availableHelper(name, runtimeVersion)) {
          return;
        }

        const isInteropHelper = HEADER_HELPERS.indexOf(name) !== -1;
        const blockHoist = isInteropHelper && !(0, _helperModuleImports.isModule)(file.path) ? 4 : undefined;
        const helpersDir = esModules && file.path.node.sourceType === "module" ? "helpers/esm" : "helpers";
        let helperPath = `${modulePath}/${helpersDir}/${name}`;
        if (absoluteRuntime) helperPath = (0, _getRuntimePath.resolveFSPath)(helperPath);
        return addDefaultImport(helperPath, name, blockHoist, true);
      });
      const cache = new Map();

      function addDefaultImport(source, nameHint, blockHoist, isHelper = false) {
        const cacheKey = (0, _helperModuleImports.isModule)(file.path);
>>>>>>> d9d57759386cbc64761f26a577729c9da898f4b0
        const key = `${source}:${nameHint}:${cacheKey || ""}`;
        let cached = cache.get(key);

        if (cached) {
<<<<<<< HEAD
          cached = _core().types.cloneNode(cached);
        } else {
          cached = (0, _helperModuleImports().addDefault)(file.path, source, {
            importedInterop: "uncompiled",
=======
          cached = _core.types.cloneNode(cached);
        } else {
          cached = (0, _helperModuleImports.addDefault)(file.path, source, {
            importedInterop: isHelper && supportsCJSDefault ? "compiled" : "uncompiled",
>>>>>>> d9d57759386cbc64761f26a577729c9da898f4b0
            nameHint,
            blockHoist
          });
          cache.set(key, cached);
        }

        return cached;
<<<<<<< HEAD
      };
    },

    visitor: {
      ReferencedIdentifier(path) {
        const {
          node,
          parent,
          scope
        } = path;

        if (node.name === "regeneratorRuntime" && useRuntimeRegenerator) {
          path.replaceWith(this.addDefaultImport(`${modulePath}/regenerator`, "regeneratorRuntime"));
          return;
        }

        if (!injectCoreJS2) return;
        if (_core().types.isMemberExpression(parent)) return;
        if (!has(definitions.builtins, node.name)) return;
        if (scope.getBindingIdentifier(node.name)) return;
        path.replaceWith(this.addDefaultImport(`${modulePath}/core-js/${definitions.builtins[node.name]}`, node.name));
      },

      CallExpression(path) {
        if (!injectCoreJS2) return;
        if (path.node.arguments.length) return;
        const callee = path.node.callee;
        if (!_core().types.isMemberExpression(callee)) return;
        if (!callee.computed) return;

        if (!path.get("callee.property").matchesPattern("Symbol.iterator")) {
          return;
        }

        path.replaceWith(_core().types.callExpression(this.addDefaultImport(`${modulePath}/core-js/get-iterator`, "getIterator"), [callee.object]));
      },

      BinaryExpression(path) {
        if (!injectCoreJS2) return;
        if (path.node.operator !== "in") return;
        if (!path.get("left").matchesPattern("Symbol.iterator")) return;
        path.replaceWith(_core().types.callExpression(this.addDefaultImport(`${modulePath}/core-js/is-iterable`, "isIterable"), [path.node.right]));
      },

      MemberExpression: {
        enter(path) {
          if (!injectCoreJS2) return;
          if (!path.isReferenced()) return;
          const {
            node
          } = path;
          const obj = node.object;
          const prop = node.property;
          if (!_core().types.isReferenced(obj, node)) return;
          if (node.computed) return;
          if (!has(definitions.methods, obj.name)) return;
          const methods = definitions.methods[obj.name];
          if (!has(methods, prop.name)) return;
          if (path.scope.getBindingIdentifier(obj.name)) return;

          if (obj.name === "Object" && prop.name === "defineProperty" && path.parentPath.isCallExpression()) {
            const call = path.parentPath.node;

            if (call.arguments.length === 3 && _core().types.isLiteral(call.arguments[1])) {
              return;
            }
          }

          path.replaceWith(this.addDefaultImport(`${modulePath}/core-js/${methods[prop.name]}`, `${obj.name}$${prop.name}`));
        },

        exit(path) {
          if (!injectCoreJS2) return;
          if (!path.isReferenced()) return;
          const {
            node
          } = path;
          const obj = node.object;
          if (!has(definitions.builtins, obj.name)) return;
          if (path.scope.getBindingIdentifier(obj.name)) return;
          path.replaceWith(_core().types.memberExpression(this.addDefaultImport(`${modulePath}/core-js/${definitions.builtins[obj.name]}`, obj.name), node.property, node.computed));
        }

      }
    }
=======
      }
    }

>>>>>>> d9d57759386cbc64761f26a577729c9da898f4b0
  };
});

exports.default = _default;