/**
 * @fileoverview Rule to disallow mixed binary operators.
 * @author Toru Nagashima
 */

"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

<<<<<<< HEAD
const astUtils = require("../util/ast-utils.js");
=======
const astUtils = require("./utils/ast-utils.js");
>>>>>>> d9d57759386cbc64761f26a577729c9da898f4b0

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

const ARITHMETIC_OPERATORS = ["+", "-", "*", "/", "%", "**"];
const BITWISE_OPERATORS = ["&", "|", "^", "~", "<<", ">>", ">>>"];
const COMPARISON_OPERATORS = ["==", "!=", "===", "!==", ">", ">=", "<", "<="];
const LOGICAL_OPERATORS = ["&&", "||"];
const RELATIONAL_OPERATORS = ["in", "instanceof"];
<<<<<<< HEAD
=======
const TERNARY_OPERATOR = ["?:"];
const COALESCE_OPERATOR = ["??"];
>>>>>>> d9d57759386cbc64761f26a577729c9da898f4b0
const ALL_OPERATORS = [].concat(
    ARITHMETIC_OPERATORS,
    BITWISE_OPERATORS,
    COMPARISON_OPERATORS,
    LOGICAL_OPERATORS,
<<<<<<< HEAD
    RELATIONAL_OPERATORS
=======
    RELATIONAL_OPERATORS,
    TERNARY_OPERATOR,
    COALESCE_OPERATOR
>>>>>>> d9d57759386cbc64761f26a577729c9da898f4b0
);
const DEFAULT_GROUPS = [
    ARITHMETIC_OPERATORS,
    BITWISE_OPERATORS,
    COMPARISON_OPERATORS,
    LOGICAL_OPERATORS,
    RELATIONAL_OPERATORS
];
<<<<<<< HEAD
const TARGET_NODE_TYPE = /^(?:Binary|Logical)Expression$/;

/**
 * Normalizes options.
 *
 * @param {Object|undefined} options - A options object to normalize.
 * @returns {Object} Normalized option object.
 */
function normalizeOptions(options) {
    const hasGroups = (options && options.groups && options.groups.length > 0);
    const groups = hasGroups ? options.groups : DEFAULT_GROUPS;
    const allowSamePrecedence = (options && options.allowSamePrecedence) !== false;
=======
const TARGET_NODE_TYPE = /^(?:Binary|Logical|Conditional)Expression$/u;

/**
 * Normalizes options.
 * @param {Object|undefined} options A options object to normalize.
 * @returns {Object} Normalized option object.
 */
function normalizeOptions(options = {}) {
    const hasGroups = options.groups && options.groups.length > 0;
    const groups = hasGroups ? options.groups : DEFAULT_GROUPS;
    const allowSamePrecedence = options.allowSamePrecedence !== false;
>>>>>>> d9d57759386cbc64761f26a577729c9da898f4b0

    return {
        groups,
        allowSamePrecedence
    };
}

/**
 * Checks whether any group which includes both given operator exists or not.
<<<<<<< HEAD
 *
 * @param {Array.<string[]>} groups - A list of groups to check.
 * @param {string} left - An operator.
 * @param {string} right - Another operator.
=======
 * @param {Array<string[]>} groups A list of groups to check.
 * @param {string} left An operator.
 * @param {string} right Another operator.
>>>>>>> d9d57759386cbc64761f26a577729c9da898f4b0
 * @returns {boolean} `true` if such group existed.
 */
function includesBothInAGroup(groups, left, right) {
    return groups.some(group => group.indexOf(left) !== -1 && group.indexOf(right) !== -1);
}

<<<<<<< HEAD
=======
/**
 * Checks whether the given node is a conditional expression and returns the test node else the left node.
 * @param {ASTNode} node A node which can be a BinaryExpression or a LogicalExpression node.
 * This parent node can be BinaryExpression, LogicalExpression
 *      , or a ConditionalExpression node
 * @returns {ASTNode} node the appropriate node(left or test).
 */
function getChildNode(node) {
    return node.type === "ConditionalExpression" ? node.test : node.left;
}

>>>>>>> d9d57759386cbc64761f26a577729c9da898f4b0
//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

<<<<<<< HEAD
module.exports = {
    meta: {
        docs: {
            description: "disallow mixed binary operators",
            category: "Stylistic Issues",
            recommended: false,
            url: "https://eslint.org/docs/rules/no-mixed-operators"
        },
=======
/** @type {import('../shared/types').Rule} */
module.exports = {
    meta: {
        type: "suggestion",

        docs: {
            description: "disallow mixed binary operators",
            recommended: false,
            url: "https://eslint.org/docs/rules/no-mixed-operators"
        },

>>>>>>> d9d57759386cbc64761f26a577729c9da898f4b0
        schema: [
            {
                type: "object",
                properties: {
                    groups: {
                        type: "array",
                        items: {
                            type: "array",
                            items: { enum: ALL_OPERATORS },
                            minItems: 2,
                            uniqueItems: true
                        },
                        uniqueItems: true
                    },
                    allowSamePrecedence: {
<<<<<<< HEAD
                        type: "boolean"
=======
                        type: "boolean",
                        default: true
>>>>>>> d9d57759386cbc64761f26a577729c9da898f4b0
                    }
                },
                additionalProperties: false
            }
<<<<<<< HEAD
        ]
=======
        ],

        messages: {
            unexpectedMixedOperator: "Unexpected mix of '{{leftOperator}}' and '{{rightOperator}}'. Use parentheses to clarify the intended order of operations."
        }
>>>>>>> d9d57759386cbc64761f26a577729c9da898f4b0
    },

    create(context) {
        const sourceCode = context.getSourceCode();
        const options = normalizeOptions(context.options[0]);

        /**
         * Checks whether a given node should be ignored by options or not.
<<<<<<< HEAD
         *
         * @param {ASTNode} node - A node to check. This is a BinaryExpression
=======
         * @param {ASTNode} node A node to check. This is a BinaryExpression
>>>>>>> d9d57759386cbc64761f26a577729c9da898f4b0
         *      node or a LogicalExpression node. This parent node is one of
         *      them, too.
         * @returns {boolean} `true` if the node should be ignored.
         */
        function shouldIgnore(node) {
            const a = node;
            const b = node.parent;

            return (
<<<<<<< HEAD
                !includesBothInAGroup(options.groups, a.operator, b.operator) ||
=======
                !includesBothInAGroup(options.groups, a.operator, b.type === "ConditionalExpression" ? "?:" : b.operator) ||
>>>>>>> d9d57759386cbc64761f26a577729c9da898f4b0
                (
                    options.allowSamePrecedence &&
                    astUtils.getPrecedence(a) === astUtils.getPrecedence(b)
                )
            );
        }

        /**
         * Checks whether the operator of a given node is mixed with parent
         * node's operator or not.
<<<<<<< HEAD
         *
         * @param {ASTNode} node - A node to check. This is a BinaryExpression
=======
         * @param {ASTNode} node A node to check. This is a BinaryExpression
>>>>>>> d9d57759386cbc64761f26a577729c9da898f4b0
         *      node or a LogicalExpression node. This parent node is one of
         *      them, too.
         * @returns {boolean} `true` if the node was mixed.
         */
        function isMixedWithParent(node) {
<<<<<<< HEAD
=======

>>>>>>> d9d57759386cbc64761f26a577729c9da898f4b0
            return (
                node.operator !== node.parent.operator &&
                !astUtils.isParenthesised(sourceCode, node)
            );
        }

        /**
         * Gets the operator token of a given node.
<<<<<<< HEAD
         *
         * @param {ASTNode} node - A node to check. This is a BinaryExpression
=======
         * @param {ASTNode} node A node to check. This is a BinaryExpression
>>>>>>> d9d57759386cbc64761f26a577729c9da898f4b0
         *      node or a LogicalExpression node.
         * @returns {Token} The operator token of the node.
         */
        function getOperatorToken(node) {
<<<<<<< HEAD
            return sourceCode.getTokenAfter(node.left, astUtils.isNotClosingParenToken);
=======
            return sourceCode.getTokenAfter(getChildNode(node), astUtils.isNotClosingParenToken);
>>>>>>> d9d57759386cbc64761f26a577729c9da898f4b0
        }

        /**
         * Reports both the operator of a given node and the operator of the
         * parent node.
<<<<<<< HEAD
         *
         * @param {ASTNode} node - A node to check. This is a BinaryExpression
=======
         * @param {ASTNode} node A node to check. This is a BinaryExpression
>>>>>>> d9d57759386cbc64761f26a577729c9da898f4b0
         *      node or a LogicalExpression node. This parent node is one of
         *      them, too.
         * @returns {void}
         */
        function reportBothOperators(node) {
            const parent = node.parent;
<<<<<<< HEAD
            const left = (parent.left === node) ? node : parent;
            const right = (parent.left !== node) ? node : parent;
            const message =
                "Unexpected mix of '{{leftOperator}}' and '{{rightOperator}}'.";
            const data = {
                leftOperator: left.operator,
                rightOperator: right.operator
=======
            const left = (getChildNode(parent) === node) ? node : parent;
            const right = (getChildNode(parent) !== node) ? node : parent;
            const data = {
                leftOperator: left.operator || "?:",
                rightOperator: right.operator || "?:"
>>>>>>> d9d57759386cbc64761f26a577729c9da898f4b0
            };

            context.report({
                node: left,
<<<<<<< HEAD
                loc: getOperatorToken(left).loc.start,
                message,
=======
                loc: getOperatorToken(left).loc,
                messageId: "unexpectedMixedOperator",
>>>>>>> d9d57759386cbc64761f26a577729c9da898f4b0
                data
            });
            context.report({
                node: right,
<<<<<<< HEAD
                loc: getOperatorToken(right).loc.start,
                message,
=======
                loc: getOperatorToken(right).loc,
                messageId: "unexpectedMixedOperator",
>>>>>>> d9d57759386cbc64761f26a577729c9da898f4b0
                data
            });
        }

        /**
         * Checks between the operator of this node and the operator of the
         * parent node.
<<<<<<< HEAD
         *
         * @param {ASTNode} node - A node to check.
         * @returns {void}
         */
        function check(node) {
            if (TARGET_NODE_TYPE.test(node.parent.type) &&
=======
         * @param {ASTNode} node A node to check.
         * @returns {void}
         */
        function check(node) {
            if (
                TARGET_NODE_TYPE.test(node.parent.type) &&
>>>>>>> d9d57759386cbc64761f26a577729c9da898f4b0
                isMixedWithParent(node) &&
                !shouldIgnore(node)
            ) {
                reportBothOperators(node);
            }
        }

        return {
            BinaryExpression: check,
            LogicalExpression: check
        };
    }
};
